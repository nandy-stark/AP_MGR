#!/bin/bash

# === PATHS ===
SCRIPT_DIR="$HOME/bin/apmgr"
CONFIG_DIR="$SCRIPT_DIR/.config"
DEFAULT_CFG="$CONFIG_DIR/default"
PREV_CFG="$CONFIG_DIR/.prev"
BASE_DIR="/integ/release/official"

# === Ensure required directories ===
mkdir -p "$CONFIG_DIR"

# === Ensure 'default' config exists ===
if [[ ! -f "$DEFAULT_CFG" ]]; then
    echo "üõ† Creating default config..."
    cat > "$DEFAULT_CFG" <<EOF
YEAR=LATEST
VERSION=AP_2025.1.1
PLATFORM=rhel9-64
EOF
fi
# === FUNCTIONS ===
print_stark_banner() {
    cat <<'EOF'
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë         STARK INDUSTRIES‚Ñ¢             ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
EOF
}

show_help() {
    print_stark_banner
    cat <<EOF
Usage:
  ap [save_name] [-L|-O|-P <path>|-p] [-v] [-l] [-s | -d]
  Invoke Aprisa and save versions by name.

Examples:
  ap dev -L         # Use latest version for dev
  ap prod -P /path/to/AP  # Save manual path for prod
  ap -p -v          # View last-used config
  ap -l             # List saved configs

  The [save_name] argument could be the name of a client project
  or company for ease of use.

Flags:
  -L   Use latest version
  -O   Interactive menu (TODO)
  -P   Manual path mode
  -p   Use previous config
  -v   View resolved path/config
  -l   List saved configs
  -s   Save resolved config
  -d   Delete a config

EOF
    exit 0
}

prompt_choice() {
    local prompt="$1"
    shift
    local options=("$@")
    if [[ ${#options[@]} -eq 0 ]]; then
        echo "No options available for: $prompt"
        exit 1
    fi
    echo ""
    echo "$prompt"
    PS3="Enter your choice number (e.g. 1): "
    select opt in "${options[@]}"; do
        if [[ -n "$opt" ]]; then
            echo "$opt"
            return
        fi
        if [[ " ${options[*]} " =~ " $REPLY " ]]; then
            echo "$REPLY"
            return
        fi
        echo "Invalid choice. Enter number or exact name:"
    done
}


# === DEFAULTS ===
SAVE_NAME="default"
CUSTOM_PATH=""
POSITIONAL=()

# === Flag variables ===
FLAG_VIEW=0
FLAG_SAVE=0
FLAG_LIST=0
FLAG_DELETE=0
FLAG_LATEST=0
FLAG_PATH_MODE=0
FLAG_PREV=0
SKIP_RESOLVE=0

# === Parse args ===
while [[ $# -gt 0 ]]; do
    case "$1" in
        -v) FLAG_VIEW=1 ;;
        -s) FLAG_SAVE=1 ;;
        -l) FLAG_LIST=1 ;;
        -d) FLAG_DELETE=1 ;;
        -L) FLAG_LATEST=1 ;;
        -O) FLAG_INTERACTIVE=1 ;;
        -P) FLAG_PATH_MODE=1; CUSTOM_PATH="$2"; shift ;;
        -p) FLAG_PREV=1 ;;
        -*) echo "‚ùå Unknown flag: $1" ; exit 1 ;;
        *) POSITIONAL+=("$1") ;;
    esac
    shift
done

# === Extract save_name (if given) ===
if [[ ${#POSITIONAL[@]} -ge 1 ]]; then
    SAVE_NAME="${POSITIONAL[0]}"
fi

CONFIG_PATH="$CONFIG_DIR/$SAVE_NAME"
# === List saved configs ===
if [[ $FLAG_LIST -eq 1 && $FLAG_VIEW -eq 1 ]]; then
    echo "Saved Configs (Detailed View):"
    for f in "$CONFIG_DIR"/*; do
        [[ -f "$f" && "$(basename "$f")" != ".prev" ]] || continue
        echo -e "\nüî∏ $(basename "$f")"
        cat "$f"
    done
    exit 0
elif [[ $FLAG_LIST -eq 1 ]]; then
    echo "Available Configs:"
    for f in "$CONFIG_DIR"/*; do
        [[ -f "$f" && "$(basename "$f")" != ".prev" ]] && echo "‚Ä¢ $(basename "$f")"
    done
    exit 0
fi

# === Delete a config ===
if [[ $FLAG_DELETE -eq 1 ]]; then
    if [[ "$SAVE_NAME" == "default" ]]; then
        echo "‚ùå Cannot delete the default config."
        exit 1
    fi
    if [[ -f "$CONFIG_PATH" ]]; then
        rm "$CONFIG_PATH"
        echo "Deleted config: $SAVE_NAME"
    else
        echo "Config '$SAVE_NAME' does not exist."
    fi
    exit 0
fi

# === Handle -p (previous config reuse) ===
if [[ $FLAG_PREV -eq 1 ]]; then
    if [[ ! -f "$PREV_CFG" ]]; then
        echo "‚ùå No previous config found."
        exit 1
    fi
    source "$PREV_CFG"
    echo "Loaded previous config from .prev"

    if [[ -n "$FULL_PATH" ]]; then
        :
    elif [[ -n "$YEAR" && -n "$VERSION" && -n "$PLATFORM" ]]; then
        FULL_PATH="$BASE_DIR/$YEAR/$VERSION/bin/$PLATFORM/AP"
    else
        echo "‚ùå Invalid .prev config (missing fields)"
        exit 1
    fi

    if [[ $FLAG_VIEW -eq 1 ]]; then
        echo "[View Mode] .prev"
        echo "FULL_PATH=$FULL_PATH"
        exit 0
    fi
fi

# === Handle -P (manual path mode) ===
if [[ $FLAG_PATH_MODE -eq 1 ]]; then
    if [[ ! -x "$CUSTOM_PATH" ]]; then
        echo "‚ùå Given path is invalid or not executable:"
        echo "   $CUSTOM_PATH"
        exit 1
    fi

    FULL_PATH="$CUSTOM_PATH"

    if [[ "$SAVE_NAME" != "default" ]]; then
        echo "FULL_PATH=$CUSTOM_PATH" > "$CONFIG_PATH"
        echo "Saved manual path to config: $SAVE_NAME"
    fi

    if [[ $FLAG_VIEW -eq 1 ]]; then
        echo "[View Mode] $SAVE_NAME"
        echo "FULL_PATH=$FULL_PATH"
        exit 0
    fi
    SKIP_RESOLVE=1
fi

# === View a config directly ===
if [[ $FLAG_VIEW -eq 1 && $FLAG_LATEST -eq 0 && $FLAG_PATH_MODE -eq 0 && $FLAG_PREV -eq 0 && $FLAG_INTERACTIVE -eq 0 ]]; then
    if [[ -f "$CONFIG_PATH" ]]; then
        echo "Config: $SAVE_NAME"
        cat "$CONFIG_PATH"
    else
        echo "Config '$SAVE_NAME' does not exist."
    fi
    exit 0
fi

# Load saved config (unless -p or -P already handled it)
if [[ -z "$FULL_PATH" && -f "$CONFIG_PATH" ]]; then
    source "$CONFIG_PATH"
    if [[ -n "$FULL_PATH" && -x "$FULL_PATH" ]]; then
	    echo "Using Path from saved config: $FULL_PATH"
	    SKIP_RESOLVE=1
    fi
fi

# Handle -L: use LATEST directory if it works, else fallback to latest year
if [[ $FLAG_LATEST -eq 1 ]]; then
    if [[ -d "$BASE_DIR/LATEST" ]]; then
        YEAR="LATEST"
        VERSIONS=()
        for dir in "$BASE_DIR/LATEST"/AP_*; do
            [[ -d "$dir" ]] && VERSIONS+=("$(basename "$dir")")
        done

        if [[ ${#VERSIONS[@]} -gt 0 ]]; then
            VERSION=$(printf "%s\n" "${VERSIONS[@]}" | sort -V | tail -n1)
            echo "Using LATEST ‚Üí $VERSION"
        else
            echo "No valid versions found in LATEST/, falling back..."
            YEAR=$(find "$BASE_DIR" -mindepth 1 -maxdepth 1 -type d \
              ! -name "LATEST" -exec basename {} \; | sort -V | tail -n1)
	    if [[ -z "$YEAR" ]]; then
    		echo "‚ùå No fallback year found in $BASE_DIR"
    		exit 1
	    fi

            VERSIONS=()
            for dir in "$BASE_DIR/$YEAR"/AP_*; do
                [[ -d "$dir" ]] && VERSIONS+=("$(basename "$dir")")
            done

            if [[ ${#VERSIONS[@]} -eq 0 ]]; then
                echo "‚ùå Still no versions found for fallback year $YEAR"
                exit 1
            fi

            VERSION=$(printf "%s\n" "${VERSIONS[@]}" | sort -V | tail -n1)
            echo "Fallback latest: $YEAR ‚Üí $VERSION"
        fi
    else
        echo "No LATEST/ directory found, falling back to latest numeric year..."
        YEAR=$(find "$BASE_DIR" -mindepth 1 -maxdepth 1 -type d \
          ! -name "LATEST" -exec basename {} \; | sort -V | tail -n1)

        VERSIONS=()
        for dir in "$BASE_DIR/$YEAR"/AP_*; do
            [[ -d "$dir" ]] && VERSIONS+=("$(basename "$dir")")
        done

        if [[ ${#VERSIONS[@]} -eq 0 ]]; then
            echo "‚ùå No versions found in fallback year: $YEAR"
            exit 1
        fi

        VERSION=$(printf "%s\n" "${VERSIONS[@]}" | sort -V | tail -n1)
        echo "Fallback latest: $YEAR ‚Üí $VERSION"
    fi
fi

if [[ $SKIP_RESOLVE -ne 1 ]]; then
  # Prompt for YEAR if still missing
  if [[ -z "$YEAR" ]]; then
      YEARS=()
      for dir in "$BASE_DIR"/*; do
          [[ -d "$dir" && "$(basename "$dir")" != "LATEST" ]] && YEARS+=("$(basename "$dir")")
      done
  
      [[ ${#YEARS[@]} -eq 0 ]] && echo "‚ùå No year directories in $BASE_DIR" && exit 1
  
      YEAR=$(prompt_choice "Select release year:" "${YEARS[@]}" </dev/tty | tail -n1)
      echo "Selected YEAR: $YEAR"
  fi
  
  # Prompt for VERSION if still missing
  if [[ -z "$VERSION" ]]; then
      VERSION_DIRS=()
      for dir in "$BASE_DIR/$YEAR"/AP_*; do
          [[ -d "$dir" ]] && VERSION_DIRS+=("$(basename "$dir")")
      done
  
      [[ ${#VERSION_DIRS[@]} -eq 0 ]] && echo "‚ùå No versions found under $YEAR" && exit 1
  
      VERSION=$(prompt_choice "Select version under $YEAR:" "${VERSION_DIRS[@]}" </dev/tty | tail -n1)
      echo "Selected VERSION: $VERSION"
  fi
  
  # Prompt for PLATFORM if still missing
  if [[ -z "$PLATFORM" ]]; then
      BIN_DIR="$BASE_DIR/$YEAR/$VERSION/bin"
      [[ ! -d "$BIN_DIR" ]] && echo "‚ùå Bin directory missing: $BIN_DIR" && exit 1
  
      PLATFORMS=()
      for dir in "$BIN_DIR"/*; do
          [[ -d "$dir" ]] && PLATFORMS+=("$(basename "$dir")")
      done
  
      [[ ${#PLATFORMS[@]} -eq 0 ]] && echo "‚ùå No platforms found in $BIN_DIR" && exit 1
  
      PLATFORM=$(prompt_choice "Select platform:" "${PLATFORMS[@]}" </dev/tty | tail -n1)
      echo "Selected PLATFORM: $PLATFORM"
  fi
  
  # Final FULL_PATH construction if not already done
  if [[ -z "$FULL_PATH" ]]; then
      FULL_PATH="$BASE_DIR/$YEAR/$VERSION/bin/$PLATFORM/AP"
  fi
fi

# Check if FULL_PATH exists and is executable
if [[ ! -x "$FULL_PATH" ]]; then
    echo "‚ùå ERROR: Resolved binary is not executable:"
    echo "   ‚Üí $FULL_PATH"
    exit 1
fi

# If we're just viewing (-v), print resolved info and exit
if [[ $FLAG_VIEW -eq 1 ]]; then
    echo "[View Mode] Resolved configuration:"
    echo "SAVE_NAME = $SAVE_NAME"
    echo "YEAR      = $YEAR"
    echo "VERSION   = $VERSION"
    echo "PLATFORM  = $PLATFORM"
    echo "FULL_PATH = $FULL_PATH"
    exit 0
fi

# Save to .prev ONLY if we're going to run it
cat > "$PREV_CFG" <<EOF
YEAR=$YEAR
VERSION=$VERSION
PLATFORM=$PLATFORM
FULL_PATH=$FULL_PATH
EOF
echo "Saved to .prev"

# Execute the program
echo "üöÄ Launching: $FULL_PATH"
exec "$FULL_PATH"
